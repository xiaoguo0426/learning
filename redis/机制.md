
## redis

**Redis本质上是一个Key-Value类型的内存数据库**，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。

#### 机制
> 单线程的Redis为什么这么快，为什么响应延迟这么低

- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用了非阻塞I/O多路复用机制

**redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销**

#### 好处

- 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

- 支持丰富数据类型，支持string，list，set，sorted set，hash

#### redis相比memcached有哪些优势？

- `memcached`所有的值均是简单的字符串，`redis`作为其替代者，支持更为丰富的数据类型
- `redis`的速度比`memcached`快很多
- `redis`可以持久化其数据

#### Memcache与Redis的区别都有哪些？

- 存储方式 `Memecache`把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。`Redis`有部份存在硬盘上，这样能保证数据的持久性。
- 数据支持类型`Memcache`对数据类型支持相对简单。`Redis`有复杂的数据类型。
- 使用底层模型不同它们之间底层实现方式以及与客户端之间通信的应用协议不一样。`Redis`直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

#### redis的缓存失效策略和主键失效机制

6种数据淘汰策略:
- **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- **allkeys-lru**：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
- **no-enviction**（驱逐）：禁止驱逐数据

使用策略规则：

- 如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru

- 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random

#### redis的并发竞争问题如何解决?

> Redis为**单进程单线程模式**，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争.
