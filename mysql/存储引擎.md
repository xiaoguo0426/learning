> 存储引擎就是指表的类型以及表在计算机上的存储方式。

### MyISAM
> mysql5.5之前版本默认存储引擎

> 不支持事务

> 存储结构：数据文件(.MYD),索引文件（.MYI）和结构文件(.frm)。可以在不同服务器上拷贝数据文件和索引文件。

> 加锁和并发。

1. 加锁：对整张表进行加锁，而不是行。
2. 在读数据的时候，所有的表上都可以获得共享锁(读锁)，每个连接都互不干扰。在写数据的时候，获得排他锁，会把整个表进行加锁，而其他的连接请求(读，写请求)都处于等待中。所以这就解释了为什么MyISAM的并发效率低，而读取效率高的原因。

> MyISAM表支持的索引类型

> MyISAM表支持数据压缩。压缩之后变成只读表。压缩之后，读取性能会更好。

> MyISAM表不支持外键

> 清空表的时候，MyISAM会重建表

> 在没有WHERE条件的情况下执行COUNT(*)操作，MyISAM只需要简单读出保存好的行数即可。


#### 适用场景
1. 非事务型应用
2. 只读类应用(数据压缩)
3. 空间类应用

### Innodb

> Innodb是一种事务型存储引擎

> 完全支持事务的ACID特性（Redo Log和Undo Log）

> mysql5.5之后版本默认存储引擎

> 存储结构：结构文件(.frm),数据文件(.ibd)

> Innodb使用表空间进行数据存储（独立表空间/系统表空间）'innodb_file_per_table'属性

> Innodb支持行级锁。行级锁可以最大程度的支持并发。行级锁是由存储引擎层实现的。

> 支持外键

https://draveness.me/mysql-innodb


#### InnoDB使用独立表空间存储与系统表空间存储区别
属性innodb_file_per_table  ON/OFF     数据存储文件不同

ON：独立表空间  tablename.ibd

OFF: 系统表空间  统一存放在ibdataX文件

区别：

  共享表空间：每一个数据库的所有表数据，索引文件全部放在一个文件中，默认在data目录下。默认ibdata，初始化10M。文件大小没有限制【64TB】。数据删除后，系统表空间大小不会改变，会造成磁盘空间浪费，产生大量磁盘碎片；会产生IO瓶颈

  独立表空间：每一个表都会生成以独立的文件方式来进行存储，每一个表都有一个.frm表来描述文件，.bid文件包含数据内容以及索引内容。独立表空间效率和性能会高点；可以实现单表在不同的数据库中移动；空间可以回收；可以同时向多个文件刷新数据；

#### 事务

> 一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务

https://www.cnblogs.com/davygeek/p/7995072.html

#### 事务ACID特性

- 原子性（Atomicity）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。
- 一致性（consistency）：事务执行完毕后将数据库从一个一致性状态转变成另一个一致性状态。
- 隔离性（isolation）：事务彼此独立，隔离的，即一个事务的执行不能被其他事务所干扰；一个事务所做的修改在最终提交之前，对于其他事务是不可见的。
- 持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。

#### 事务日志

事务日志可以帮助提高事务的效率。**使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘**。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序IO，而不像随机IO需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。通常称之为预写式日志（Write-Ahead Logging），修改数据需要写两次磁盘。

数据库通常借助日志来实现事务，常见的有redo log 重做日志 和 undo log 回滚日志。undo/redo log 能够保证事务特性， **undo log实现事务原子性，redo log 实现事务的持久性**。

###### 事务原子性：
事务的所有操作，要么全部完成，要不都不做，不能只做一半。如果在执行的过程中发生了错误，要回到事务开始时的状态，所有的操作都要回滚。

原理：
  Undo log 为了满足事务的原子性，在操作任何数据之前，首先将数据备份到Undo log中，然后进行数据的修改。如果出现了错误或者用户实行了rollback语句，系统可以利用Undo log中的备份数据恢复到事务开始之前的状态。

![](assets/markdown-img-paste-20190906093302165.png)

###### 事务持久性：

mysql使用重做日志redo log实现事务的持久性。
重做日志由两部分组成，一是内存中的重做日志缓冲区，因为重做缓冲区在内存中，所以它是易丢失的；另一个就是磁盘上的重做日志文件，它是持久的。

![](assets/markdown-img-paste-20190906101111968.png)

当我们在一个事务中尝试对数据进行修改时，它会先将数据从磁盘读入内存，并更新内存中缓存的数据，然后生成一条重做日志并写入重做日志缓存，当事务真正提交时，mysql会将重做日志缓存中的内容刷新到重做日志文件，再将内存中的数据更新到磁盘中。图中4,5步就是在事务提交时执行的。


###### 事务隔离级别：
- READ UNCOMMITTED（未提交读）
特点：允许一个事务读取另一个事务未提交的数据。这种隔离级别下，可能会出现脏读（Dirty Read），即读取到其他事务尚未提交的数据。
> 适用场景：适用于对数据一致性要求不高的场景，如日志记录等。
- READ COMMITTED（提交读）
特点：一个事务只能读取到其他事务已经提交的数据。这种隔离级别下，避免了脏读，但可能会出现不可重复读（Non-Repeatable Read），**即在同一个事务中，多次读取同一数据可能会得到不同的结果**。
> 适用场景：适用于大多数需要数据一致性的场景，但对数据的重复性要求不高。
- REPEATABLE READ（可重复读）
特点：保证在同一个事务中，多次读取同一数据会得到相同的结果。这种隔离级别下，避免了脏读和不可重复读，但可能会出现幻读（Phantom Read），**即在同一个事务中，多次读取同一范围的数据可能会得到不同的结果**。
> 适用场景：适用于需要数据一致性和重复性的场景，如金融交易等。
MySQL 默认隔离级别：MySQL 默认的事务隔离级别是 REPEATABLE READ。
- SERIALIZABLE（可串行化）
特点：最高的隔离级别，保证事务的串行执行，避免了脏读、不可重复读和幻读。这种隔离级别下，**事务会以串行的方式执行，可能会导致性能下降**。
> 适用场景：适用于对数据一致性要求极高的场景，如银行系统等。



## 并发控制器机制

- 锁
- 时间戳
- 多版本和快照隔离

### 什么是锁

> 锁对主要作用是管理共享资源的并发访问

> 锁用于实现事务的隔离性

### 锁的类型

1. 共享锁（也称读锁）
2. 独占锁（也称写锁，排他锁）

### 锁的粒度

1. 表级锁
  - 开销小，加锁快
  - 不会出现死锁
  - 锁定粒度大，发生锁冲突的概率最高，并发度最低
2. 行级锁
  - 开销大，加锁慢
  - 会出现死锁
  - 锁定粒度最小，发生锁冲突的概率最低，并发度最高
3. 页面锁
  - 开销和加锁时间介于表锁和行锁之间
  - 会出现死锁
  - 锁定粒度介于表锁和行锁之间，并发度一般
4. 元数据锁
  - 在MySQL中，元数据锁（Metadata Locks）是一种内部锁机制，用于在执行DDL（数据定义语言）操作时保护数据库的元数据结构，如表结构、视图等。这些锁确保在多个DDL操作同时执行时，不会发生冲突或数据不一致。
  
    元数据锁的类型: 
    全局元数据锁（Global Metadata Lock）：这种锁用于对整个数据库实例的元数据进行保护，例如在执行FLUSH TABLES WITH READ LOCK时。

本地元数据锁（Local Metadata Lock）：这种锁用于保护特定数据库或表的元数据。

常见的元数据锁操作
ALTER TABLE：在执行ALTER TABLE命令时，会获取该表的元数据锁。

CREATE/DROP TABLE：在创建或删除表时，会获取相应表的元数据锁。

RENAME TABLE：在重命名表时，会获取相关表的元数据锁。

TRUNCATE TABLE：在清空表时，会获取表的元数据锁。

元数据锁的影响
当一个会话持有表的元数据锁时，其他会话将无法对该表执行DDL操作，直到持有锁的会话释放锁。这可能导致DDL操作的阻塞，特别是在高并发环境中。
### 阻塞和死锁

> 阻塞 是因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它占有的资源，这就是阻塞。阻塞并不是一件坏事，是为了保证事务可以并发并且正确的运行。

> 死锁 是指两个或两个以上的进程在执行过程中，因争取资源而造成的一种相互等待的现象，若无外力作用，他们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在相互等待的进程成为死锁进程。表级锁不会产生死锁，死锁常见于Innodb存储引擎。解决方案：1.通过innodb_lock_wait_timeout来设置；2.发现死锁后，主动回滚死锁链条中的某个事务，让其他事务得以继续执行，再重新执行因死锁被回滚的事务即可；将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

减少死锁的主要方向，就是`控制访问相同资源的并发事务量`。


### 时间戳

![](assets/markdown-img-paste-20190906104037607.png)

> 使用时间戳实现事务的隔离性时，往往都会使用乐观锁，先对数据进行修改，在写回时再判断当前值，也就是时间戳是否被改变过，如果没有改变过，就写入，否则，生成一个新的时间戳并在此更新数据，乐观锁其实并不是真正的锁机制，它只是一种思想。

```mysql

update tbl_product set sales = 5 + 1 where product_id = 1 and sales = 5;

```

在`set`写回的时候，加上初始状态的条件compare，只有初始状态不变时，才允许`set`写回成功，`Compare And Set(CAS)`，是一种常见的降低读写锁冲突，保证数据一致性的方法。
