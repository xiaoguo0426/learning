## 索引

- 存储引擎层实现索引
- 索引大大减少了存储引擎需要扫描的数据量
- 索引可以帮助我们进行排序，减少比使用临时表的IO消耗，提升MYSQL能力
- 索引可以把随机IO变为顺序IO

###### 索引是不是越多越好？

- 索引会增加写操作成本 【数据在进行插入，更新，删除的同时要对相关的索引进行维护，索引越多，修改数据越多，时间越久】
- 太多的索引会增加查询优化器的选择时间

### 类型
- BTree索引
- B+Tree索引
- 哈希索引
- 全文索引


##### 哈希索引
> 只有memory（内存）存储引擎支持，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存该值所在行数据的物理地址，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，并且是散列的分布式方式，因此哈希索引不支持范围查找和排序功能。

##### 全文索引
> 紧可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。主要针对文本，或较大的char类型的数据；在生成FULLTEXT索引时，会生成一份单词的清单，在索引时及根据这个单词的清单来索引；全文索引的查询有自己的语法，不能使用模糊查询语句。


##### B树索引
- 全值匹配的查询

- 匹配最左前缀的查询

- 匹配列前缀查询

- 匹配范围值的查找


#### 索引优化策略
- 索引列上不能使用表达式或函数



#### 联合索引
##### 如何选择索引列的顺序

- 经常会被使用到的列优先
- 选择性高的列优先
- 宽度小的列优先


#### 覆盖索引

- 可以优化缓存，减少磁盘IO操作
- 可以减少随机IO，变随机IO操作变为顺序IO操作
- 可以避免对InnoDB主键索引的二次查询【回表】
- 可以避免MyISAM表进行系统调用

###### 无法使用覆盖索引的情况
- 存储引擎不支持覆盖索引
- 查询中使用了太多的列
- 使用了双%号的like查询

###### 使用索引扫描来优化排序
- 索引的列顺序和Order By子句的顺序完全一致
- 索引中的所有列的方向（升序，降序）和Order By子句完全一致
- Order By中的字段全部在关联表中的第一张表中
